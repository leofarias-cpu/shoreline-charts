# Raccoon

Collection of helpers to enable development of next-js apps on the VTEX admin.

---

<img src="/assets/banner.jpeg" alt="raccoon" width="100%" />

Table of Contents

- [The recipe](#the-recipe)
- [Integration App](#integration-app)
  - [Basic usage](#basic-usage)
  - [Advanced usage](#advanced-usage)
  - [Basic or Advanced, which one should I use?](#basic-or-advanced-which-one-should-i-use)
- [The next app](#the-next-app)
  - [I18n](#i18n)
  - [Proxy requests](#proxy-requests)
- [Setup the application host](#setup-the-application-host)
- [Setup the repository](#setup-the-repository)
- [SDK Documentations](#sdk-documentation)
- [Library development](#library-development)
  - [Releasing a new version](#releasing-a-new-version)

## üßÅ The recipe

Follow the steps below to create a raccoon application.

1. Create and setup an Integration application
2. Create and setup a Next application
3. Setup the application host
4. Setup the repository

In the next sections you will understand how to accomplish each one of the steps.

## Integration app (VTEX IO application)

This app is responsible for creating an integration between VTEX IO and the Next JS application, it's necessary so we can access IO information such as token, account, workspace, and render-runtime data from the Next project.

There are two ways of creating an Integration App, the Basic and the Advanced way, but in both of them you'll need to create a new IO application, the only difference will be the `builders` used in each one of them.

### Basic usage

By default, the admin shell abstracts part of the Integration App creation within the admin builder which cover the most part of the scenarios while making it easier to implement this application.

#### Architecture

<img src="/assets/basic-integration-app.png" alt="raccoon" width="100%" />

#### Implementation

**Admin builder**

1. Create a navigation.json:

```json
// /admin/navigation.json
{
  "section": "desired_section", // orders, for example
  "titleId": "admin-example.navigation.label-group", // you should add this on your messages
  "adminVersion": 4, // only for v4 :)
  "subSection": "desired_subSection",
  "subSectionItems": [
    {
      "labelId": "admin-example.navigation.label-main", // also on messages
      "path": "/admin/example", // your raccoon app base path
      "raccoon": {
        "prodUrl": "production-url", // this is where your app is hosted
        "devUrl": "dev-url" // this is where your dev preview is hosted, by default it is set to localhost:3000 and the field is optional
      }
    }
  ]
}
```

### Advanced usage

If you need a specific behavior from IO that is not covered by our abstraction you can also create your own Integration App from scratch, to do that just follow the Admin, Node, and React builder implementation examples shown below.

> **Warning**
>
> Be aware that by using the advanced way you are implementing an application which is rendered within an Iframe inside of another Iframe.

#### Architecture

<img src="/assets/advanced-integration-app.png" alt="raccoon" width="100%" />

#### Implementation

**Admin builder**

1. Create a navigation.json:

```json
// /admin/navigation.json
{
  "section": "desired_section", // orders, for example
  "titleId": "admin-example.navigation.label-group", // you should add this on your messages
  "adminVersion": 4, // only for v4 :)
  "subSection": "desired_subSection",
  "subSectionItems": [
    {
      "labelId": "admin-example.navigation.label-main", // also on messages
      "path": "/admin/example" // your app route
    }
  ]
}
```

2. Create a slug based route:

```json
// /admin/routes.json
{
  "admin.app.example": {
    "component": "EmbeddedApp",
    "path": "/admin/app/example/*slug" // this will allow next js routing to run free
  }
}
```

**React builder**

1. Install the `@vtex/raccoon-io` package: `yarn add @vtex/raccoon-io`.
2. Add the iframe to render the next app:

```tsx
// /react/embedded-app.tsx
import React from "react";
import { useRuntime } from "vtex.render-runtime";
import { Iframe, useIframeState } from "@vtex/raccoon-io";

const PROD_URL = "production-url"; // this is where yout app is hosted
const BASE_PATH = "/admin/example"; // base path of routes.json without the *slug

export default function EmbeddedApp() {
  const {
    account,
    workspace,
    production,
    navigate
    culture: { locale, currency },
  } = useRuntime();

  const state = useIframeState({
    prodUrl: PROD_URL,
    basePath: BASE_PATH,
    runtime: {
      account,
      workspace,
      production,
      locale,
      currency,
    },
    asyncHandlers: {
      handlerName: (data: T) => {
        // some action
      },
    },
  });

  return <Iframe state={state} />;
}
```

**Node builder**

This is how we retrieve the `token` necessary to make IO requests from the next app.

1. Expose a new route that returns the token.

```json
// node/service.json
{
  "routes": {
    "token": {
      "public": true,
      "path": "/_v/admin-embedded-app/token"
    }
  }
}
```

2. Retrieve the token from the cookie `VtexIdclientAutCookie`.

```ts
// /node/index.ts
import { method, Service } from '@vtex/api'
import type { ParamsContext, RecorderState } from '@vtex/api'

// Export a service that defines resolvers and clients' options
export default new Service<any, RecorderState, ParamsContext>({
  routes: {
    token: method({
      GET: (ctx: any) => {
        ctx.body = {
          token: ctx.cookies.get('VtexIdclientAutCookie'),
        }

        ctx.set('cache-control', 'no-store, no-cache')
        ctx.status = 200
      },
    }),
  },
})
```

### Basic or Advanced, which one should I use?

To answer that you can ask yourself if you need to handle several things within an IO application that it isn't possible only with the Next app. If the answer is yes, go ahead with the `advanced` way, and if the answer is no or if you are unsure about it, go ahead with the `basic` one.

## The next app

1. Create an app using the next-js cli: `npx create-next-app my-app --typescript`.
2. Add the `@vtex/raccoon-next` package: `yarn add @vtex/raccoon-next`.
3. Bootstrap raccoon on the `_app.tsx`:

```tsx
import type { AppProps } from 'next/app'
import { connect, bootstrap } from '@vtex/raccoon-next'

connect()

function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}

export default bootstrap(App)
```

### I18n

There isn't a single way of adding i18n to your next application, since now the developers aren't stucked to IO's message builder and they also have more control over the technology used.

You can feel free to choose the way of adding i18n and if you want one example we have [this Github discussion that shares one way of doing it.](https://github.com/vtex/raccoon/discussions/25)

#### Crowdin

There is only one thing similar and mandatory no matter which i18n method you choose, and that is to configure the crowdin file. Just to provide you some context, [Crowdin](https://crowdin.com/) is the tool used by the localization team to automate and agile the app translation process. This file should be in the app root and you can set it up like this:

```yml
// crowdin.yml file
files:
  - source: /path-to-your-messages-folder/messages/en.json
    translation: /%original_path%/%two_letters_code%.%file_extension%
  # If you have more than one source, you can just add multiple sources here.
  - source: /path-to-another-messages-folder/messages/en.json
    translation: /%original_path%/%two_letters_code%.%file_extension%
...
```

### Proxy requests

Since the next application runs in a host different from `{account}.myvtex.com` when you try to make a request to one of VTEX APIs it will probably return a `CORS` error. To fix that you need to implement a proxy to work around this error. [You can find detailed information on how to implement a proxy in this discussion](https://github.com/vtex/raccoon/discussions/39), if you want to share your solution feel free to write it there!

## Setup the application host

For now we don't have a definition of which host you should use in your application. For starting the development you can follow with `Vercel` which is simple and easy to setup, but keep in mind that this tool has a high cost, so before deploying the app to be used by VTEX clients this should be considered.

> **Note**
>
> We have plans of defining the best host for these new applications that runs outside the render. Once we have it we'll share and document how you should procceed.

## Setup the repository

You can setup your repository in many different ways:

1. Monorepo, where the Integration App and the Next app will be in the same repository. [Example](https://github.com/vtex/admin-catalog-facelift)
2. Different repos, where one will be for the Integration app and the other one to the Next app.

## SDK Documentations

- [Next SDK](./next-sdk.md)
- [IO SDK](./io-sdk.md)

## Library Development [üöß WIP]

Ensure you are following the conventional commits rules when commiting code.

### Releasing a new version

Once anything reaches the `main` branch, semantic-release evaluates if a new release is needed according with the commit messages.
