import { rm } from 'fs/promises'
import * as TypeDoc from 'typedoc'
import type { Config, PkgToBeDocumented } from './config'
import { defaultTypedocConfig, getTmpDocsJsonPath } from './config'
import { parseJSONDocs } from './parser'
import { readFileSync } from 'fs'
import type {
  FunctionParser,
  InterfaceParser,
  TypeAliasParser,
} from 'typedoc-json-parser'
import { ProjectParser } from 'typedoc-json-parser'

/**
 * This script is responsible for generating the docs for the components and
 * hooks of a package. It uses typedoc to generate the docs and then it splits
 * the generated docs into multiple markdown files on the paths configured
 * by the client under a package.
 *
 * @param packages The packages to be documented
 * @example
 * new AutogeneratedDocs(packages)
 */
class AutogeneratedDocs {
  private config: Config

  constructor(config: Config) {
    this.config = config
    this.generateDocs()
  }

  /**
   * Configures TypeDoc, generates the JSON documentation and then parses it.
   * This is the entrypoint of this script.
   *
   * @param config The typedoc config
   */
  private async generateDocs() {
    const apps = await Promise.all(
      this.config.pkgs.map((pkg) =>
        TypeDoc.Application.bootstrapWithPlugins({
          ...pkg.config,
          ...defaultTypedocConfig,
        })
      )
    )

    const projects = await Promise.all(apps.map((app) => app.convert()))

    if (!projects.every(Boolean)) {
      throw new Error('Something went wrong while generating docs')
    }

    const tmpDocsJsonPaths = this.config.pkgs.map((pkg) =>
      getTmpDocsJsonPath(pkg.name)
    )

    await Promise.all(
      projects.map((project, i) =>
        apps[i].generateJson(project!, tmpDocsJsonPaths[i])
      )
    )

    const data = this.config.pkgs.map((pkg) =>
      JSON.parse(readFileSync(getTmpDocsJsonPath(pkg.name), 'utf8'))
    )

    const parsers = data.map((datum) => new ProjectParser({ data: datum }))
    const [functions, interfaces, typeAliases] = parsers.reduce<
      [FunctionParser[], InterfaceParser[], TypeAliasParser[]]
    >(
      (acc, curr) => {
        return [
          acc[0].concat(curr.functions),
          acc[1].concat(curr.interfaces),
          acc[2].concat(curr.typeAliases),
        ]
      },
      [[], [], []]
    )

    await parseJSONDocs(functions, interfaces, typeAliases, this.config.paths)

    await Promise.all(
      tmpDocsJsonPaths.map((tmpDocsJsonPath) =>
        rm(tmpDocsJsonPath, { force: true, recursive: true })
      )
    )
  }
}

/**
 * @todo move this to a config file/cli
 */
const pkgs: PkgToBeDocumented[] = [
  {
    name: '@vtex/shoreline-components',
    version: '^0.x',
    config: {
      entryPoints: ['../components/src/index.ts'],
      exclude: [
        '../components/src/**/*+(index|.vitest|.e2e|.test|.stories).(ts|tsx)',
      ],
      tsconfig: '../components/tsconfig.json',
    },
  },
  {
    name: '@vtex/shoreline-date',
    version: '^0.x',
    config: {
      entryPoints: ['../date/src/index.ts'],
      exclude: [
        '../date/src/**/*+(index|.vitest|.e2e|.test|.stories).(ts|tsx)',
      ],
      tsconfig: '../date/tsconfig.json',
    },
  },
]

const config: Config = {
  pkgs,
  paths: {
    components: {
      docPath: `../docs/pages/components`,
      filename: 'api-reference.mdx',
    },
  },
}

new AutogeneratedDocs(config)
