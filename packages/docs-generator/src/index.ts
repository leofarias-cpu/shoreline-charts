/* eslint-disable no-await-in-loop */

import { readFileSync, readdirSync, rmdirSync } from 'fs'
import * as TypeDoc from 'typedoc'
import { paths, tokens } from './config'
import { handleComponents, handleHooks, handleTypeAliases } from './handlers'
import { pascalCaseToKebabCase, cleanFile } from './strings'
import { createOrUpdateFile, copyFolderRecursiveSync } from './io'

// @TODO
// [ ] Lint for typedocs
// [x] Split util methods into separate files
// [ ] Create use cases for: Simple components vs Stateful components vs Hooks vs Compound components
// [x] Remove "NOTE: Exotic components are not callable" mean?
// [x] Put examples on hold
// [ ] Move hierarchy to related components
// [ ] Compound components hierarchy: Combobox ComboboxItem | Combobox > ComboboxItem

/**
 * This script is responsible for generating the docs for the components and
 * hooks of a package. It uses typedoc to generate the docs and then it splits
 * the generated docs into multiple nextra files.
 *
 * It also generates a Sandpack example for each component and hook.
 *
 * The script is run manually, but it could be packaged as a separate module
 * and published to npm to benefit the community.
 */
class AutogeneratedDocs {
  constructor(props: {
    packages: Array<{
      name: string
      version: string
      paths: {
        componentsPath?: string
        hooksPath?: string
      }
    }>
    rootPath: string
  }) {
    const { packages, rootPath } = props

    for (const pkg of packages) {
      const { paths } = pkg

      this.generateDocs(paths, rootPath)
    }
  }

  /**
   * Split the generated docs from typedoc into multiple nextra files.
   * This is the main function of the script.
   */
  private async generateDocs(
    configPaths: {
      componentsPath?: string
      hooksPath?: string
    },
    rootPath: string
  ) {
    const { componentsPath = undefined, hooksPath = undefined } = configPaths

    const app = await TypeDoc.Application.bootstrapWithPlugins({
      // @TODO: Move this to a config file
      entryPoints: ['../components/src/index.ts'],
      exclude: [
        '../components/src/**/*+(index|.vitest|.e2e|.test|.stories).(ts|tsx)',
      ],
      excludeExternals: true,
      externalPattern: ['**/node_modules/**'],
      tsconfig: '../components/tsconfig.json',
      commentStyle: 'all',
      out: '__tmpDocs',
      plugin: ['typedoc-plugin-markdown', 'typedoc-plugin-mdn-links'],
      // @ts-expect-error - since these options come from typedoc-plugin-markdown options, which are not typed
      hideInPageTOC: true,
      hideBreadcrumbs: true,
    })

    const project = await app.convert()

    if (!project) {
      throw new Error('Something went wrong while generating docs')
    }

    const outputDir = app.options.getValue('out')

    await app.generateDocs(project, outputDir)

    const rootFile = readFileSync(`${paths.tmp}/modules.md`, 'utf8')
    const interfacesFiles = readdirSync(`${paths.tmp}/interfaces`)

    const rootFileContent = cleanFile(rootFile)

    const components: string[] = []
    const hooks: string[] = []

    for (const fileContents of rootFileContent) {
      try {
        // Parse file contents
        const content = fileContents.split('\n')

        const methodName = content
          // Find the line that starts with "###", which is the component/method/hook name
          .find((line: string) => line.startsWith(tokens.methodDocStart))
          ?.replace(tokens.methodDocStart, tokens.empty)
          .trim()

        if (methodName) {
          // Means that this is a component
          const isPascalCase = /^[A-Z][a-zA-Z0-9]*$/.test(methodName)
          // Means that this is a hook, matches camelCase methods starting with "use"
          const isHook = /^use[A-Z][a-zA-Z0-9]*$/.test(methodName)
          // Check if element is a component. This is a bit hacky, but it works
          // since typedoc classifies type-declared type as type aliases under
          // the modules.md file, while it separates interface-declared types
          // under the interfaces folder
          const isTypeAlias = methodName.includes(tokens.props)

          if (isHook && !isTypeAlias) {
            await handleHooks(methodName, fileContents, hooks)

            continue
          }

          if (isPascalCase && !isHook && !isTypeAlias) {
            await handleComponents(
              methodName,
              fileContents,
              interfacesFiles,
              components
            )

            continue
          }

          if (isTypeAlias && !isHook) {
            await handleTypeAliases(methodName, fileContents)

            continue
          }
        }
      } catch (error) {
        console.error(error)
      }
    }

    // Move everything under config.paths.tmp to the docs folder
    const pagesPath = `${paths.cwd}${rootPath}`
    const componentsMetaJson = `${paths.cwd}${componentsPath}/_meta.json`
    const hooksMetaJson = `${paths.cwd}${hooksPath}/_meta.json`

    // Base path is set to /components here but could come from some configuration
    copyFolderRecursiveSync(`${paths.tmp}/components`, pagesPath)

    if (components.length > 0) {
      // Update componentsMetaJson with the new paths
      // Adds the components as kebab-case on keys and PascalCase on values
      let componentsMetaUpdated = components.reduce((acc, cur) => {
        return {
          ...acc,
          [pascalCaseToKebabCase(cur)]: cur,
        }
      }, {})

      if (hooks.length > 0) {
        componentsMetaUpdated = Object.assign(
          componentsMetaUpdated,
          // Add the Hooks key as the last item on the componentsMetaJson
          {
            hooks: 'Hooks',
          }
        )
      }

      // Write the updated componentsMetaJson to disk as a simple JSON file
      await createOrUpdateFile(
        componentsMetaJson,
        JSON.stringify(componentsMetaUpdated, null, 2)
      )
    }

    if (hooks.length > 0) {
      // Update hooksMetaJson with the new paths
      // Adds the components as kebab-case on keys and camelCase on values
      const hooksMetaUpdated = hooks.reduce((acc, cur) => {
        return {
          ...acc,
          [pascalCaseToKebabCase(cur)]: cur,
        }
      }, {})

      // Write the updated componentsMetaJson or create if not exists
      await createOrUpdateFile(
        hooksMetaJson,
        JSON.stringify(hooksMetaUpdated, null, 2)
      )
    }

    // Remove temporary folder
    rmdirSync(paths.tmp, { recursive: true })
  }
}

new AutogeneratedDocs({
  // @TODO: Move this to a config file
  packages: [
    {
      name: '@vtex/shoreline-components',
      version: '^0.x',
      paths: {
        componentsPath: `/../next-docs/pages/components`,
        hooksPath: `/../next-docs/pages/components/hooks`,
      },
    },
  ],
  rootPath: `/../next-docs/pages`,
})
