---
title: Radio
path: /radio/
hide_table_of_contents: true
---

import { Page, Panel } from '@site/src/components/Page'

export const tabToc = {
  overview: toc.filter((item) => ['Example'].includes(item.value)),
  codeReference: toc.filter((item) =>
    [
      'Usage',
      'State',
      'Props',
      'useRadioState',
      'Standalone',
      'Checked States',
      'Size',
      'Multiple Radios',
    ].includes(item.value)
  ),
  designReference: toc.filter((item) => ['Doâ€™s'].includes(item.value)),
}

<Page toc={tabToc} hasTabs>
  <Panel id="overview">

Radio buttons are tools that customize configurations. They represent a need for the user to make a choice among a few offered options. In multiple choice forms, use radio buttons for a single option to be selected. This component is always used in a `RadioGroup` context.

## Example

```jsx live
function Example() {
  const state = useRadioState()

  return <Radio state={state} value="Radio" aria-label="radio button" />
}
```

  </Panel>
  <Panel id="codeReference">

## Usage

```jsx isStatic
import { Radio } from '@vtex/admin-ui'
```

## State

The `Radio` component is always used in a `RadioGroup` context, we provide a hook to handle the state of radio groups and standalone radios.

### useRadioState

_hook_

For convenience, we provide this hook that already handles the state logic and accessible navigation for both `Radio` and `RadioGroup` components. You should pass the hook return to the `state` property and define a `value` to the `Radio`.

### Standalone

When using a standalone `Radio` you should provide an `aria-label` property value. As a `form` component, it should have a label specified to guarantee accessibility.

```jsx live
function Example() {
  const radio = useRadioState()

  return <Radio aria-label="label" value="Radio" state={radio} />
}
```

### Checked States

There are two checked states: `not checked`, and `checked`.

```jsx live
function Example() {
  return (
    <>
      <Set>
        <Radio aria-label="label-1" />
        <Radio aria-label="label-disabled-1" disabled />
      </Set>
      <br />
      <Set>
        <Radio aria-label="label-2" checked />
        <Radio aria-label="label-disabled-2" checked disabled />
      </Set>
    </>
  )
}
```

### Size

There are two size variants: `small`, `regular`. By default, it will render `regular`.

```jsx live
function Example() {
  return (
    <>
      <Set>
        <Radio aria-label="label-small-1" size="small" />
        <Radio aria-label="label-1" />
      </Set>
      <br />
      <Set>
        <Radio aria-label="label-small-2" checked size="small" />
        <Radio aria-label="label-2" checked />
      </Set>
    </>
  )
}
```

### Multiple Radios

As we always use `Radio` in multiple-choice forms, we also always need to render multiple Radios and store the current checked state. It can be easily done using our `useRadioState` hook, you just need to pass the hook return object to the radios `state` property and define a `value` for each `Radio`.

```jsx live
function Example() {
  const radio = useRadioState()

  return (
    <>
      <Heading>Selected Radio: {radio.state}</Heading>
      <RadioGroup state={radio}>
        <Label>
          <Radio state={radio} value="First Radio" />
          First Radio
        </Label>
        <Label>
          <Radio state={radio} value="Second Radio" />
          Second Radio
        </Label>
        <Label>
          <Radio state={radio} value="Third Radio" />
          Third Radio
        </Label>
      </RadioGroup>
    </>
  )
}
```

## Props

| Name     | Type                | Description                                                                          | Required | Default     |
| -------- | ------------------- | ------------------------------------------------------------------------------------ | -------- | ----------- |
| state    | `RadioStateReturn`  | Return of useRadio hook. You can also provide these props from your own state logic. | âœ…       | -           |
| size     | `regular, small`    | Radio size                                                                           | ðŸš«       | `'regular'` |
| checked  | `boolean`           | Same as the HTML checked attribute                                                   | ðŸš«       | -           |
| disabled | `boolean`           | Defines if the Radio is disabled                                                     | ðŸš«       | -           |
| value    | `string, number`    | Same as the HTML attribute                                                           | ðŸš«       | -           |
| name     | `string`            | Same as the HTML value attribute                                                     | ðŸš«       | -           |
| onClick  | `MouseEventHandler` | Same as the HTML attribute                                                           | ðŸš«       | -           |
| onBlur   | `FocusEventHandler` | Same as the HTML attribute                                                           | ðŸš«       | -           |
| onFocus  | `FocusEventHandler` | Same as the HTML attribute                                                           | ðŸš«       | -           |
| id       | `string`            | Same as the HTML attribute                                                           | ðŸš«       | -           |
| children | `ReactNode`         | Radio children                                                                       | ðŸš«       | -           |
| csx      | `StyleProp`         | Defines component styles                                                             | ðŸš«       | `{}`        |

  </Panel>
  <Panel id="designReference">

## Doâ€™s

1. Use them for multiple choice options.
2. There should always be a pre-selected option as default.
3. Keep the list of options short. More than 6 options might start looking weird.
4. Donâ€™t be ambiguous, each option should be clear.
5. Mind the order of the options. Consider ordering them from most to least frequently used, simplest to most complex, or least to most risky.
6. Use a "None" option if you need an unselected state.
   7, Consider adding an "Other" option if needed, together with a Text Input to capture the userâ€™s needs.
7. Use titles to group related controls.
8. Add descriptions if the control is critical, or complex.
9. Lists of controls should be vertical for better scannability.

ðŸ‘‰ For UX Writing guidelines, access https://uxwriting.vtex.com

  </Panel>
</Page>
