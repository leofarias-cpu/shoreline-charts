import { Section } from '@site/src/components/Section'

<Section hasExplanation>

## Usage

```jsx
import {
  Table,
  TBody,
  TBodyRow,
  TBodyCell,
  THead,
  THeadCell,
  useTableState,
} from '@vtex/admin-ui'

const columns = createColumns([
  {
    id: 'productName',
    header: 'Product name',
  },
  {
    id: 'inStock',
    header: 'In Stock',
  },
  {
    id: 'price',
    header: 'Price',
  },
  {
    id: 'skus',
    header: 'SKUs',
  },
])

function Example() {
  /**
   * The hook returns the Table state
   */
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    /**
     * Columns shape, read more about it on the rendering section
     */
    columns,
    /**
     * List of items to render
     */
    items: [
      {
        id: 1,
        productName: 'Orange',
        inStock: 380,
        skus: 0,
        price: 120,
      },
    ],
  })
  /**
   * You must use the `state` prop so that your Table comes to life
   * This is the only prop that is required
   */
  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.productName}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}
```

</Section>

<Section hasExplanation>

## State

The state hook `useTableState` contains all business logic needed for the component.

</Section>

<Section>

### useTableState

| Name    | Type                    | Description                                                                | Required | Default |
| ------- | ----------------------- | -------------------------------------------------------------------------- | -------- | ------- |
| columns | `Column<T>[]`           | Table column spec                                                          | âœ…       | -       |
| status  | `DataViewStatus`        | Related DataView status                                                    | ðŸš«       | -       |
| context | `ResolverContext`       | Resolver context                                                           | ðŸš«       | -       |
| items   | `T[]`                   | Table items                                                                | ðŸš«       | `[]`    |
| length  | `number`                | Expected items length, this will also control the number of skeleton items | ðŸš«       | `5`     |
| sort    | `UseTableSortParams<T>` | useTableSort hook params                                                   | ðŸš«       | -       |

<br />
It returns an object with the following types:
<br />

```ts
export interface UseTableStateReturn<T> {
  /**
   * Collection rendered while loading
   */
  skeletonCollection: T[]
  /**
   * Resolves the cell content
   */
  resolveCell: (args: ResolverCallee<ResolveCellArgs<T>>) => ReactNode
  /**
   * Resolvers the header content
   */
  resolveHeader: (
    args: ResolverCallee<ResolveHeaderArgs<T>>
  ) => ResolveHeaderReturn
  /**
   * Items to render
   */
  data: T[]
  /**
   * Grid columns
   */
  columns: Array<TableColumn<T>>
  /**
   * Current sorting state
   */
  sortState: UseSortReturn
  /**
   * Table ref
   */
  tableRef: RefObject<HTMLTableElement>
  /**
    TBody cell props
  */
  getBodyCell: (
    column: TableColumn<T, BaseResolvers<T>>,
    item: T
  ) => TableBodyCellProps<T>
  /**
    THead cell props
  */
  getHeadCell: (
    column: TableColumn<T, BaseResolvers<T>>
  ) => TableHeadCellProps<T>
  /**
    Table props
  */
  getTable: () => TableProps<T>
  /**
  DataView related status
  */
  status: DataViewStatus
}
```

</Section>

<Section hasExplanation>

## Rendering

The main objective of `Table` is to provide a flexible render to support any kind of data type.

| Attribute | Type                                            | Description                                                                                                                                                                                                                         | Required |
| --------- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |
| id        | `string`                                        | String that defines the property name that the column represents.                                                                                                                                                                   | âœ…       |
| header    | `((column: Column<T>) => ReactNode), or string` | Controls the title which appears on the table Header.<br />It can receive either a string or an element.                                                                                                                            | ðŸš«       |
| accessor  | `((item: T) => ReactNode), or string`           | Defines how to access a property                                                                                                                                                                                                    | ðŸš«       |
| resolver  | `R`                                             | [Resolvers](#resolvers) api<br />Will select the [plain resolver](#plain) by default                                                                                                                                                | ðŸš«       |
| width     | `number`                                        | Defines a fixed width for the specific column.<br />Receives either a string or number.<br />By default, the column's width is defined to fit the available space without breaking the content.                                     | ðŸš«       |
| sortable  | `(a: T, b: T) => number`                        | Defines if that column is sortable or not, passing true to this prop won't sort items by itself, the sorting will still need to be handled using the sort prop inside the StatelessTable sort prop. Check [Sorting](table/#sorting) | ðŸš«       |
| compare   | `boolean`                                       | The function provided to handle the sorting of this column of the table, if this function is provided the table items will be sorted based on this function result. Check [Sorting](table/#sorting)                                 | ðŸš«       |

</Section>

<Section hasExplanation>

## Accessor

Some properties may be nested within objects and arrays. The `accessor` properties provide an easy way to access those.

```jsx noInline live
const columns = createColumns([
  {
    id: 'product.name',
    header: 'Name',
    width: '2fr',
    resolver: {
      type: 'text',
      columnType: 'name',
      mapText: (item) => item.product.name,
      render: ({ data }) => <Box csx={{ minWidth: '10rem' }}>{data}</Box>,
    },
  },
  {
    id: 'product.brand',
    header: 'Brand',
    width: '1fr',
    accessor: 'product.brand.0',
  },
  {
    id: 'rates',
    header: 'Price',
    width: '1fr',
    accessor: (item) => {
      const {
        rates: { price, discount },
      } = item
      return price - discount
    },
    resolver: {
      type: 'currency',
      locale: 'en-US',
      currency: 'USD',
    },
  },
  {
    id: 'status',
    header: 'Status',
    width: '1fr',
    resolver: {
      type: 'root',
      render: ({ item }) => {
        return <Tag label={item.status} size="normal" />
      },
    },
  },
  {
    resolver: {
      type: 'menu',
      actions: [
        {
          label: 'View details',
          icon: <IconEye />,
        },
      ],
    },
  },
])

const items = [
  {
    id: 495953,
    product: {
      name: 'Wooden Eyeglasses',
      brand: ['Revolution'],
    },
    status: 'Inactive',
    rates: {
      price: 52.14,
      discount: 10,
    },
  },
  {
    id: 429048,
    product: {
      name: 'Brazil Straw Hat',
      brand: ['Pathway'],
    },
    status: 'Inactive',
    rates: {
      price: 49.52,
      discount: 11,
    },
  },
  {
    id: 495954,
    product: {
      name: 'Striped Beach Short',
      brand: ['Desire Spirit'],
    },
    status: 'Inactive',
    rates: {
      price: 53.59,
      discount: 30.1,
    },
  },
]

function Example() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
  })

  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.product.name}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}

render(<Example />)
```

</Section>

<Section hasExplanation>

## Resolvers

Resolvers are rendering functions that target a specific data type. The main usage is to render the same data types consistently along with admin applications.

</Section>

<Section hasExplanation>

### Render function

All resolvers accept a render function, that returns a component. It controls the data rendering, which may be treated by the resolver or not.

```ts
{
  type: 'resolver name',
  /**
   * You have 3 render props here:
   * { item, data, context }
   */
  render: function Render({ item, data, context }) {
    return <></>
  }
}
```

| Name    | Type                   | Description                                                         |
| ------- | ---------------------- | ------------------------------------------------------------------- |
| item    | `T`                    | the item displayed for the row                                      |
| data    | `unknown`              | extracted column data from the item, you need to cast it before use |
| context | `{ loading: boolean }` | relevant global information about the table current state           |

</Section>

<Section hasExplanation>

### Root

This is the parent of all other resolvers. It does not treat the data at all - even the loading state is completely up to you. Use it if you want complete control over what's being rendered on the cell, and don't mind the complexity that it brings.

```jsx noInline live
const columns = createColumns([
  {
    id: 'name',
    header: 'Name',
    width: '6fr',
    resolver: {
      type: 'text',
      columnType: 'name',
      mapText: (item) => item.name,
    },
  },
  /**
   * The great thing about the root resolver is that you can infer new columns from
   * multiple properties of the item.
   */
  {
    id: 'status',
    header: 'Status',
    width: '1fr',
    resolver: {
      type: 'root',
      /**
       * { data } here would be null, because there is no such prop in the item
       */
      render: ({ item, context }) => {
        /**
         * You should declare the render while loading
         * this is only required by the root resolver
         * on the other ones, we take care of this for you
         */
        if (context.status === 'loading') {
          return <Skeleton className={csx({ height: 24 })} />
        }
        /**
         * You should declare the render while loading
         * this is only required by the root resolver
         * on the other ones, we take care of this for you
         */
        return <Tag label={item.status} size="normal" />
      },
    },
  },
  {
    id: 'price',
    header: 'Price',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'en-US',
      currency: 'USD',
    },
  },
  {
    id: 'brand',
    header: 'Brand',
    width: '4fr',
  },
])

const items = [
  {
    id: 495953,
    name: 'Wooden Eyeglasses',
    brand: 'Revolution',
    status: 'Inactive',
    price: 52.14,
  },
  {
    id: 429048,
    name: 'Brazil Straw Hat',
    brand: 'Pathway',
    status: 'Inactive',
    price: 49.52,
  },
  {
    id: 495954,
    name: 'Striped Beach Short',
    brand: 'Desire Spirit',
    status: 'Inactive',
    price: 53.59,
  },
]

function Example() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
  })

  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.productName}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}

render(<Example />)
```

| Name   | Type                                                  | Description              | Required |
| ------ | ----------------------------------------------------- | ------------------------ | -------- |
| type   | `root`                                                | Root resolver type       | âœ…       |
| render | ` (props: ResolverRenderProps<null, T>) => ReactNode` | Resolver render function | âœ…       |

</Section>

<Section hasExplanation>

### Plain

The plain resolver is the default for all columns. It means that if you don't select a resolver, this is what you're rendering. It should be mainly used to render raw data like strings or numbers that don't need treatment.

```jsx noInline live
const items = [
  {
    id: 495953,
    name: 'Wooden Eyeglasses',
    brand: 'Revolution',
    status: 'Inactive',
    price: 52.14,
  },
  {
    id: 429048,
    name: 'Brazil Straw Hat',
    brand: 'Pathway',
    status: 'Inactive',
    price: 49.52,
  },
  {
    id: 495954,
    name: 'Striped Beach Short',
    brand: 'Desire Spirit',
    status: 'Inactive',
    price: 53.59,
  },
]

const columns = createColumns([
  {
    id: 'name',
    width: '4fr',
    header: 'Product name',
  },
  {
    id: 'id',
    width: '1fr',
    header: 'ID',
  },
  {
    id: 'brand',
    width: '2fr',
    header: 'Brand',
  },
])

function Example() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
  })

  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.productName}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}

render(<Example />)
```

| Name   | Type                                                      | Description              | Required |
| ------ | --------------------------------------------------------- | ------------------------ | -------- |
| type   | `plain`                                                   | Plain resolver type      | âœ…       |
| render | `(props: ResolverRenderProps<ReactNode, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section hasExplanation>

### Text

The text resolver should be mainly used to render a text and an optional description just below it. For descriptions that are too long, it is possible to truncante it by setting the `overflow` prop.
This resolver must be used on the `name` column of the table.

```jsx noInline live
const items = [
  {
    id: 1,
    productName: 'Orange',
    description:
      'An orange is a fruit of various citrus species in the family Rutaceae (see list of plants known as orange);',
    price: 5.1,
    revenue: {
      value: 1223.49,
      trend: 0.3091,
    },
  },
  {
    id: 2,
    productName: 'Lemon',
    description:
      'The lemon (Citrus limon) is a species of small evergreen trees in the flowering plant family Rutaceae, native to Asia, primarily Northeast India (Assam), Northern Myanmar or China',
    revenue: {
      value: 257.36,
      trend: -0.7862,
    },
  },
  {
    id: 3,
    productName: 'Tomato',
    description:
      'The tomato is the edible berry of the plant Solanum lycopersicum,[1][2] commonly known as the tomato plant.',
    revenue: {
      value: 742.19,
      trend: 0.0,
    },
  },
]

const columns = createColumns([
  {
    id: 'productName',
    header: 'Name',
    resolver: {
      type: 'text',
      columnType: 'name',
      overflow: 'ellipsis',
      mapText: (item) => item.productName,
      mapDescription: (item) => item.description,
    },
  },
  {
    id: 'revenue',
    header: 'Revenue',
    resolver: {
      type: 'plain',
      /**
       * this is how to use the render function
       */
      render: function Render({ data }) {
        const color =
          data.trend > 0
            ? '$positive'
            : data.trend < 0
            ? '$critical'
            : '$warning'

        return (
          <Stack align="end" className={csx({ width: '100%' })}>
            <Text variant="body">
              <FormattedNumber
                value={data.value}
                style="currency"
                currency="USD"
              />
            </Text>
            <Stack
              direction="row"
              space="$space-1"
              className={csx({
                color,
                text: 'detail',
                width: '100%',
                justifyContent: 'end',
              })}
            >
              <FormattedNumber
                value={Math.abs(data.trend)}
                style="percent"
                minimumFractionDigits="2"
              />
            </Stack>
          </Stack>
        )
      },
    },
  },
  {
    resolver: {
      type: 'menu',
      actions: [
        {
          label: 'View details',
          icon: <IconEye />,
        },
      ],
    },
  },
])

function Example() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
  })

  return (
    <IntlProvider>
      <Table {...getTable()}>
        <THead>
          {columns.map((column) => (
            <THeadCell {...getHeadCell(column)} />
          ))}
        </THead>
        <TBody>
          {data.map((item) => {
            return (
              <TBodyRow
                key={item.id}
                onClick={() => alert(`Item: ${item.productName}`)}
              >
                {columns.map((column) => {
                  return <TBodyCell {...getBodyCell(column, item)} />
                })}
              </TBodyRow>
            )
          })}
        </TBody>
      </Table>
    </IntlProvider>
  )
}

render(<Example />)
```

| Name           | Type                                                      | Description                                                      | Required | Default |
| -------------- | --------------------------------------------------------- | ---------------------------------------------------------------- | -------- | ------- |
| type           | `text`                                                    | Text resolver type                                               | âœ…       | -       |
| columnType     | `name or text`                                            | Column text type                                                 | ðŸš«       | `text`  |
| mapText        | `(item: T) => ReactNode`                                  | The map function which returns the text to be rendered           | âœ…       | -       |
| mapDescription | `(item: T) => ReactNode`                                  | The map Function which returns the description to be rendered    | ðŸš«       | -       |
| overflow       | `ellipsis or auto`                                        | It specifies how overflowed text should be signaled to the user. | ðŸš«       | -       |
| render         | `(props: ResolverRenderProps<ReactNode, T>) => ReactNode` | Resolver render function                                         | ðŸš«       | -       |

</Section>

<Section hasExplanation>

### Menu

The menu resolver should be used when you want to easily render a Menu component and a set of actions.

```jsx noInline live
const columns = createColumns([
  {
    id: 'name',
    header: 'Name',
    width: '3fr',
    resolver: {
      type: 'text',
      columnType: 'name',
      mapText: (item) => item.name,
      render: ({ data }) => <Box csx={{ minWidth: '10em' }}>{data}</Box>,
    },
  },
  {
    id: 'brand',
    header: 'Brand',
    width: '2fr',
  },
  {
    id: 'price',
    header: 'Price',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'en-US',
      currency: 'USD',
    },
  },
  {
    id: 'status',
    header: 'Status',
    width: '1fr',
    resolver: {
      type: 'root',
      render: ({ item }) => {
        return <Tag label={item.status} size="normal" />
      },
    },
  },
  {
    resolver: {
      type: 'menu',
      actions: [
        {
          label: 'View details',
          icon: <IconEye />,
        },
        {
          label: 'Edit',
          icon: <IconPencil />,
          onClick: (item) => {
            console.log(item)
          },
        },
      ],
    },
  },
])

const items = [
  {
    id: 495953,
    name: 'Wooden Eyeglasses',
    status: 'Inactive',
    brand: 'Revolution',
    price: 42.14,
  },
  {
    id: 429048,
    name: 'Brazil Straw Hat',
    status: 'Inactive',
    brand: 'Pathway',
    price: 38.52,
  },
  {
    id: 495954,
    name: 'Striped Beach Short',
    status: 'Inactive',
    brand: 'Desire Spirit',
    price: 23.49,
  },
]

function Example() {
  const view = useDataViewState()
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    status: view.status,
    columns,
    items,
  })

  return (
    <DataView state={view} csx={{ paddingX: '$space-3' }}>
      <Table {...getTable()}>
        <THead>
          {columns.map((column) => (
            <THeadCell {...getHeadCell(column)} />
          ))}
        </THead>
        <TBody>
          {data.map((item) => {
            return (
              <TBodyRow
                key={item.id}
                onClick={() => alert(`Item: ${item.name}`)}
              >
                {columns.map((column) => {
                  return <TBodyCell {...getBodyCell(column, item)} />
                })}
              </TBodyRow>
            )
          })}
        </TBody>
      </Table>
    </DataView>
  )
}

render(<Example />)
```

| Name    | Type                                                        | Description                                  | Required | Default |
| ------- | ----------------------------------------------------------- | -------------------------------------------- | -------- | ------- |
| type    | `menu`                                                      | Menu resolver type                           | âœ…       | -       |
| actions | `MenuAction[]`                                              | A set of actions to be rendered as MenuItems | âœ…       | -       |
| render  | `(props: ResolverRenderProps<JSX.Element, T>) => ReactNode` | Resolver render function                     | ðŸš«       | -       |

#### MenuAction

| Name     | Type                | Description                             | Required | Default |
| -------- | ------------------- | --------------------------------------- | -------- | ------- |
| label    | `string`            | MenuItem label                          | âœ…       | -       |
| onClick  | `(item: T) => void` | MenuItem onClick handler                | âœ…       | -       |
| icon     | `ReactNode`         | MenuItem icon                           | ðŸš«       | -       |
| disabled | `boolean`           | Whether the MenuItem is disabled or not | ðŸš«       | `false` |
| critical | `boolean`           | Whether the MenuItem is critical or not | ðŸš«       | `false` |

</Section>

<Section>

### Currency

```jsx noInline live
const items = [
  {
    id: 1,
    brl: 1242.14,
    usd: 1242.14,
    cny: 1242.14,
    sar: 1242.14,
  },
  {
    id: 1,
    brl: 738.52,
    usd: 738.52,
    cny: 738.52,
    sar: 738.52,
  },
  {
    id: 1,
    brl: 23.49,
    usd: 23.49,
    cny: 23.49,
    sar: 23.49,
  },
]

const columns = createColumns([
  {
    id: 'usd',
    header: 'Price',
    width: '2fr',
    resolver: {
      type: 'currency',
      locale: 'en-US',
      currency: 'USD',
    },
  },
  {
    id: 'sar',
    header: 'Ø¹Ù…Ù„Ø©',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'ar-SA',
      currency: 'SAR',
    },
  },
  {
    id: 'cny',
    header: 'ä»·æ ¼',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'zh-CN',
      currency: 'CNY',
    },
  },
  {
    id: 'brl',
    header: 'PreÃ§o',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'pt-BR',
      currency: 'BRL',
    },
  },
])

function Example() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
  })

  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.productName}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}

render(<Example />)
```

| Name     | Type                                                   | Description              | Required |
| -------- | ------------------------------------------------------ | ------------------------ | -------- |
| type     | `currency`                                             | Currency resolver type   | âœ…       |
| locale   | `string`                                               | Currency locale          | âœ…       |
| currency | `string`                                               | Currency type            | âœ…       |
| render   | `(props: ResolverRenderProps<string, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section>

### Date

```jsx noInline live
function Example() {
  const items = [
    {
      id: 1,
      pt: '9/14/2022, 13:04',
      ar: '9/14/2022, 13:04',
      en: '9/14/2022, 13:04',
      cn: '9/14/2022, 13:04',
    },
    {
      id: 2,
      pt: '7/1/2002, 13:04',
      ar: '7/1/2002, 13:04',
      en: '7/1/2002, 13:04',
      cn: '7/1/2002, 13:04',
    },
    {
      id: 3,
      pt: '3/21/2013, 13:04',
      ar: '3/21/2013, 13:04',
      en: '3/21/2013, 13:04',
      cn: '3/21/2013, 13:04',
    },
  ]

  const columns = createColumns([
    {
      id: 'en',
      header: 'Date',
      resolver: {
        type: 'date',
        locale: 'en-US',
        options: {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        },
      },
    },
    {
      id: 'pt',
      header: 'Data',
      resolver: {
        type: 'date',
        locale: 'pt-BR',
        options: {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        },
      },
    },
    {
      id: 'ar',
      header: 'ØªØ§Ø±ÙŠØ®',
      resolver: {
        type: 'date',
        locale: 'ar-AE',
        options: {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        },
      },
    },
    {
      id: 'cn',
      header: 'æ—¥æœŸ',
      resolver: {
        type: 'date',
        locale: 'zh-CN',
        options: {
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        },
      },
    },
  ])

  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
  })

  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.productName}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}

render(<Example />)
```

| Name    | Type                                                   | Description              | Required |
| ------- | ------------------------------------------------------ | ------------------------ | -------- |
| type    | `date`                                                 | Date resolver type       | âœ…       |
| locale  | `string`                                               | Date locale              | âœ…       |
| options | `Intl.DateTimeFormatOptions`                           | Date options             | ðŸš«       |
| render  | `(props: ResolverRenderProps<string, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section>

### Image

```jsx noInline live
const columns = createColumns([
  {
    id: 'image',
    resolver: {
      type: 'image',
    },
  },
  {
    id: 'name',
    header: 'Name',
    width: '6fr',
    resolver: {
      type: 'text',
      columnType: 'name',
      mapText: (item) => item.name,
      render: ({ data }) => <Box csx={{ minWidth: '10em' }}>{data}</Box>,
    },
  },
  {
    id: 'brand',
    header: 'Brand',
    width: '4fr',
  },
  {
    id: 'price',
    header: 'Price',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'en-US',
      currency: 'USD',
    },
  },
  {
    id: 'status',
    header: 'Status',
    width: '1fr',
    resolver: {
      type: 'root',
      render: ({ item }) => {
        return <Tag label={item.status} size="normal" />
      },
    },
  },
  {
    resolver: {
      type: 'menu',
      actions: [
        {
          label: 'View details',
          icon: <IconEye />,
        },
        {
          label: 'Edit',
          icon: <IconPencil />,
          onClick: (item) => {
            console.log(item)
          },
        },
      ],
    },
  },
])

const items = [
  {
    id: 495953,
    name: 'Wooden Eyeglasses',
    status: 'Inactive',
    brand: 'Revolution',
    price: 42.14,
    image: 'https://storecomponents.vtexassets.com/arquivos/Image-2.png',
  },
  {
    id: 429048,
    name: 'Brazil Straw Hat',
    status: 'Inactive',
    brand: 'Pathway',
    price: 38.52,
    image: 'https://storecomponents.vtexassets.com/arquivos/Image-1.png',
  },
  {
    id: 495954,
    name: 'Striped Beach Short',
    status: 'Inactive',
    brand: 'Desire Spirit',
    price: 23.49,
    image: 'https://storecomponents.vtexassets.com/arquivos/image.png',
  },
]

function Example() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
  })

  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.productName}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}

render(<Example />)
```

| Name   | Type                                                        | Description              | Required |
| ------ | ----------------------------------------------------------- | ------------------------ | -------- |
| type   | `image`                                                     | Image resolver type      | âœ…       |
| alt    | `string`                                                    | HTML img alt             | ðŸš«       |
| render | `(props: ResolverRenderProps<JSX.Element, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section hasExplanation>

### Bulk

The bulk resolver should be used when you want to add a bulk actions to the table. It is a easier way of using the [BulkActions](bulk-actions) component within the Table.
When using this resolver there are two things you should follow in order to work properly: wrap the Table component with the `SelectionTree` component and avoid adding more than 25 items per page.

```jsx noInline live
const NUMBER_OF_ITEMS = 100
const ITEMS_PER_PAGE = 5

const defaultItems = Array(NUMBER_OF_ITEMS)
  .fill()
  .map((_, id) => {
    return {
      id: `${id}`,
      name: faker.commerce.productName(),
      brand: faker.random.arrayElement([
        'Revolution',
        'Desire Spirit',
        'Pathway',
        'AeroSmart',
        'Quality Prints',
        'Traction Race',
      ]),
      price: faker.commerce.price(),
      status: 'Inactive',
    }
  })

/**
 * Function to simulate a request
 * You can configure the delay and numberOfItems here
 */
function request(init, end, delay = 500) {
  return new Promise(function (resolve) {
    setTimeout(resolve, delay, defaultItems.slice(init, end))
  })
}

function Example() {
  const [items, setItems] = React.useState([])
  const view = useDataViewState()
  const pagination = usePaginationState({
    pageSize: ITEMS_PER_PAGE,
    total: NUMBER_OF_ITEMS,
  })

  const bulk = useBulkActions({
    totalItems: pagination.total,
    pageItems: items,
    pageSize: ITEMS_PER_PAGE,
  })

  const columns = createColumns([
    { id: 'id', resolver: { type: 'bulk', state: bulk } },
    ,
    {
      id: 'name',
      header: 'Name',
      width: '3fr',
      resolver: {
        type: 'text',
        columnType: 'name',
        mapText: (item) => item.name,
        render: ({ data }) => <Box csx={{ minWidth: '10rem' }}>{data}</Box>,
      },
    },
    {
      id: 'brand',
      header: 'Brand',
      width: '2fr',
    },
    {
      id: 'price',
      header: 'Price',
      width: '1fr',
      resolver: {
        type: 'currency',
        locale: 'en-US',
        currency: 'USD',
      },
    },
    {
      id: 'status',
      header: 'Status',
      width: '1fr',
      resolver: {
        type: 'root',
        render: ({ item }) => {
          return <Tag label={item.status} size="normal" />
        },
      },
    },
    {
      resolver: {
        type: 'menu',
        actions: [
          {
            label: 'View details',
            icon: <IconEye />,
          },
        ],
      },
    },
  ])

  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    status: view.status,
    columns,
    items,
  })

  React.useEffect(() => {
    view.setStatus({ type: 'loading' })
    request(pagination.range[0] - 1, pagination.range[1]).then((pageItems) => {
      setItems(pageItems)
      view.setStatus({ type: 'ready' })
    })
  }, [pagination.currentPage])

  return (
    <DataView state={view}>
      <DataViewHeader>
        <FlexSpacer />
        <Pagination state={pagination} />
        <BulkActions state={bulk}>
          <Button variant="tertiary" icon={<IconPencil />}>
            Edit
          </Button>
          <Button variant="tertiary" icon={<IconCopySimple />}>
            Duplicate
          </Button>
          <Button variant="criticalTertiary" icon={<IconTrash />}>
            Delete
          </Button>
        </BulkActions>
      </DataViewHeader>
      <SelectionTree state={bulk.selectionTree}>
        <Table {...getTable()}>
          <THead>
            {columns.map((column) => (
              <THeadCell {...getHeadCell(column)} />
            ))}
          </THead>
          <TBody>
            {data.map((item) => {
              return (
                <TBodyRow key={item.id} selected={bulk.isItemSelected(item)}>
                  {columns.map((column) => {
                    return <TBodyCell {...getBodyCell(column, item)} />
                  })}
                </TBodyRow>
              )
            })}
          </TBody>
        </Table>
      </SelectionTree>
    </DataView>
  )
}

render(<Example />)
```

| Name   | Type                                                      | Description                          | Required |
| ------ | --------------------------------------------------------- | ------------------------------------ | -------- |
| type   | `bulk`                                                    | Bulk resolver type                   | âœ…       |
| state  | `BulkActionsState<T>`                                     | The useBulkActions hook state return | âœ…       |
| render | `(props: ResolverRenderProps<ReactNode, T>) => ReactNode` | Resolver render function             | ðŸš«       |

</Section>

<Section hasExplanation>

### Selection

The selection resolver should be used when it is necessary to have rows selectable and to have control of which rows are selected.

```jsx noInline live
const columns = createColumns([
  {
    id: 'id',
    resolver: {
      type: 'selection',
      mapId: (item) => item.id,
    },
  },
  {
    id: 'name',
    header: 'Name',
    width: '2fr',
    resolver: {
      type: 'text',
      columnType: 'name',
      mapText: (item) => item.name,
      render: ({ data }) => <Box csx={{ minWidth: '10rem' }}>{data}</Box>,
    },
  },
  {
    id: 'brand',
    header: 'Brand',
    width: '1fr',
    resolver: {
      type: 'root',
      render: ({ item }) => {
        return <Box csx={{ minWidth: '5rem' }}>{item.brand}</Box>
      },
    },
  },
  {
    id: 'price',
    header: 'Price',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'en-US',
      currency: 'USD',
    },
  },
  {
    id: 'status',
    header: 'Status',
    width: '1fr',
    resolver: {
      type: 'root',
      render: ({ item }) => {
        return <Tag label={item.status} size="normal" />
      },
    },
  },
  {
    resolver: {
      type: 'menu',
      actions: [
        {
          label: 'View details',
          icon: <IconEye />,
        },
      ],
    },
  },
])

const items = [
  {
    id: 495953,
    name: 'Wooden Eyeglasses',
    status: 'Inactive',
    brand: 'Revolution',
    price: 42.14,
  },
  {
    id: 429048,
    name: 'Brazil Straw Hat',
    status: 'Inactive',
    brand: 'Pathway',
    price: 38.52,
  },
  {
    id: 495954,
    name: 'Striped Beach Short',
    status: 'Inactive',
    brand: 'Desire Spirit',
    price: 23.49,
  },
]

function Example() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    length: 3,
    items,
  })

  const selection = useSelectionTreeState({
    items: data,
    mapId: (item) => item.id,
  })

  return (
    <SelectionTree state={selection}>
      <Table {...getTable()}>
        <THead>
          {columns.map((column) => (
            <THeadCell {...getHeadCell(column)} />
          ))}
        </THead>
        <TBody>
          {data.map((item) => {
            return (
              <TBodyRow
                key={item.id}
                onClick={() => alert(`Item: ${item.productName}`)}
              >
                {columns.map((column) => {
                  return <TBodyCell {...getBodyCell(column, item)} />
                })}
              </TBodyRow>
            )
          })}
        </TBody>
      </Table>
    </SelectionTree>
  )
}

render(<Example />)
```

| Name   | Type                                                      | Description              | Required                                                         |
| ------ | --------------------------------------------------------- | ------------------------ | ---------------------------------------------------------------- | --- |
| type   | `selection`                                               | Selection resolver type  | âœ…                                                               |
| mapId  | `mapId: (item: T) => string                               | number`                  | The map function which returns the id to be used by the checkbox | ðŸš«  |
| render | `(props: ResolverRenderProps<ReactNode, T>) => ReactNode` | Resolver render function | ðŸš«                                                               |

</Section>

<Section hasExplanation>

## Sorting

To use the base sorting configuration, that matches the majority of use cases, you just need to pass the `compare` function to the columns that you want to sort by. Two params are accepted, representing two items - you must return a boolean that proves their equality.

```ts
type Compare = (a: T, b: T) => boolean
```

</Section>

<Section hasExplanation>

### Configuration

The following example allows ordering by `name`, `creation` and `price`. By using the `sort` property within `useTableState` you can configure the sorting to match specific use cases.

```jsx noInline live
const items = [
  {
    id: 495953,
    name: 'Wooden Eyeglasses',
    creation: faker.date.past().toDateString(),
    price: 42.14,
  },
  {
    id: 429048,
    name: 'Brazil Straw Hat',
    creation: faker.date.past().toDateString(),
    price: 38.52,
  },
  {
    id: 495954,
    name: 'Striped Beach Short',
    creation: faker.date.past().toDateString(),
    price: 23.49,
  },
]

const columns = createColumns([
  {
    id: 'name',
    header: 'Name',
    width: '2fr',
    compare: (a, b) => b.name.localeCompare(a.name),
  },
  {
    id: 'creation',
    header: 'Created date',
    width: '1fr',
    compare: (a, b) => {
      const aCreation = new Date(a.creation).valueOf()
      const bCreation = new Date(b.creation).valueOf()

      return bCreation - aCreation
    },
  },
  {
    id: 'price',
    header: 'Price',
    width: '1fr',
    resolver: {
      type: 'currency',
      locale: 'en-US',
      currency: 'USD',
    },
    compare: (a, b) => parseInt(b.price, 10) - parseInt(a.price, 10),
  },
])

function CompareExample() {
  const { data, getBodyCell, getHeadCell, getTable } = useTableState({
    columns,
    items,
    sort: {
      initialValue: { order: 'ASC' },
    },
  })

  return (
    <Table {...getTable()}>
      <THead>
        {columns.map((column) => (
          <THeadCell {...getHeadCell(column)} />
        ))}
      </THead>
      <TBody>
        {data.map((item) => {
          return (
            <TBodyRow
              key={item.id}
              onClick={() => alert(`Item: ${item.productName}`)}
            >
              {columns.map((column) => {
                return <TBodyCell {...getBodyCell(column, item)} />
              })}
            </TBodyRow>
          )
        })}
      </TBody>
    </Table>
  )
}

render(<CompareExample />)
```

</Section>

<Section>

#### initialValue

- Defines the table's initial sorting value. `{ order?: 'ASC' | 'DESC', by?: string }`

- The `order` prop is related to the sorting order and `by` indicates which column is being sorted, this value should be the id of the column.

</Section>

<Section>

#### directions

- Defines the sorting order of the table.
- It accepts an array with `ASC` and `DESC` as possible values.
  You can pass an array with one or two sorting directions. If you pass an array with only one sorting direction the table will only sort in one direction.

</Section>

<Section>

#### reducer

- Receives the reducer that will be used inside of the `useReducer` that handles the sorting state, it is not required and if not provided the default reducer function will be used.

- The reducer function is called with the current sort state `{ order?: SortOrder, by?: string }` and the sorting action `{ type: SortOrder | 'RESET', columnId?: string }`.

</Section>

<Section>

#### callback

- Receives a function that will be fired when the user clicks the table header cell of a column.

- This function is called with an object containing the current sort state, the dispatch of the current `useReducer` that handles the sorting state, the column id of the column that was clicked, and the current sort directions being used.

</Section>
