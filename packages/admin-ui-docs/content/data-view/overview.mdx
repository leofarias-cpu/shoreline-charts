---
title: DataView
path: /patterns/data-view/
---

import { Section } from '@site/src/components/Section'
import { IntroSection } from '@site/src/components/IntroSection'

<IntroSection>

## What is this?

DataView containers allow merchants to view and control a set of items in one or more layout types.

</IntroSection>

## Header

The `DataViewHeader` arranges all the components that control or changes the displayed data. These components can be buttons, search forms, pagination, menus, filters, and so on.

```jsx live
function Example() {
  const view = useDataViewState()
  const search = useSearchState()
  const toolbar = useToolbarState()

  return (
    <DataView state={view}>
      <DataViewHeader>
        <Flex justify="space-between" csx={{ width: '100%' }}>
          <Search id="search" placeholder="Search" state={search} />
          <DataViewActions>
            <Button variant="neutralTertiary" icon={<IconPlus />}>
              Label
            </Button>
            <Button variant="neutralTertiary" icon={<IconPlus />}>
              Label
            </Button>
          </DataViewActions>
        </Flex>
      </DataViewHeader>
    </DataView>
  )
}
```

## Rendering Data

The `useDataViewState` keeps track of `ready`, `loading`, `empty`, `error`, and `not-found` states. It also has default illustrations for `empty`, `error`, and `not-found` so that you only need to handle the `ready` and `loading` states.

```jsx live
function RenderingData() {
  const view = useDataViewState()
  const toolbar = useToolbarState()

  const content = React.useMemo(
    (item) => {
      switch (view.status) {
        // Renders Data text if ready
        case 'ready': {
          return <p>Data</p>
        }
        // Rendes a Spinner if loading
        case 'loading': {
          return <Spinner size={24} />
        }
        // Don't render anything if empty, error or not-found
        // The illustrations will be rendered by the DataView
        default: {
          return null
        }
      }
    },
    [view.status]
  )

  return (
    <DataView state={view}>
      <DataViewHeader>
        <DataViewActions>
          <Button
            size="small"
            variant="neutralTertiary"
            onClick={() =>
              view.setStatus({
                type: 'ready',
              })
            }
          >
            Ready
          </Button>
          <Button
            size="small"
            variant="neutralTertiary"
            onClick={() =>
              view.setStatus({
                type: 'loading',
              })
            }
          >
            Loading
          </Button>
          <Button
            size="small"
            variant="neutralTertiary"
            onClick={() =>
              view.setStatus({
                type: 'error',
                action: {
                  text: 'Try again!',
                  onClick: () => alert('Trying again'),
                },
              })
            }
          >
            Error
          </Button>
          <Button
            size="small"
            variant="neutralTertiary"
            onClick={() =>
              view.setStatus({
                type: 'not-found',
              })
            }
          >
            Not found
          </Button>
          <Button
            size="small"
            variant="neutralTertiary"
            onClick={() =>
              view.setStatus({
                type: 'empty',
                action: {
                  text: 'Create item',
                  onClick: () => alert('Item created'),
                },
              })
            }
          >
            Empty
          </Button>
        </DataViewActions>
      </DataViewHeader>
      {content}
    </DataView>
  )
}
```

### With Skeleton

Example of a skeleton collection.

```jsx noInline live
const NUMBER_OF_ITEMS = 5

const items = Array(NUMBER_OF_ITEMS)
  .fill()
  .map((_, id) => {
    return {
      id: `${id}`,
      name: faker.commerce.productName(),
    }
  })

function SkeletonCollection() {
  const view = useDataViewState()
  const search = useSearchState()
  const toolbar = useToolbarState()

  const data = React.useMemo(() => {
    return items.filter((item) =>
      item.name.toLowerCase().startsWith(
        // use the search debounced value to
        // filter the collection
        search.debouncedValue.toLocaleLowerCase()
      )
    )
  }, [search.debouncedValue])

  const renderItem = React.useCallback(
    (item) => {
      switch (view.status) {
        case 'ready': {
          return <p>{item.name}</p>
        }
        case 'loading': {
          return (
            <Skeleton
              csx={{
                width: 256,
                height: 24,
              }}
            />
          )
        }
        default: {
          return null
        }
      }
    },
    [view.status]
  )

  return (
    <DataView state={view}>
      <DataViewHeader>
        <Flex justify="space-between" csx={{ width: '100%' }}>
          <Search id="search" placeholder="Search" state={search} />
          <DataViewActions>
            <Button
              size="small"
              variant="neutralTertiary"
              onClick={() =>
                view.setStatus({
                  type: 'ready',
                })
              }
            >
              Ready
            </Button>

            <Button
              size="small"
              variant="neutralTertiary"
              onClick={() =>
                view.setStatus({
                  type: 'loading',
                })
              }
            >
              Loading
            </Button>
            <Button
              size="small"
              variant="neutralTertiary"
              onClick={() =>
                view.setStatus({
                  type: 'error',
                  action: {
                    text: 'Try again!',
                    onClick: () => alert('Trying again'),
                  },
                })
              }
            >
              Error
            </Button>
            <Button
              size="small"
              variant="neutralTertiary"
              onClick={() =>
                view.setStatus({
                  type: 'not-found',
                })
              }
            >
              Not found
            </Button>
            <Button
              size="small"
              variant="neutralTertiary"
              onClick={() =>
                view.setStatus({
                  type: 'empty',
                  action: {
                    text: 'Create item',
                    onClick: () => alert('Item created'),
                  },
                })
              }
            >
              Empty
            </Button>
          </DataViewActions>
        </Flex>
      </DataViewHeader>
      {(view.status === 'loading' || view.status === 'ready') &&
        data.map((item) => (
          <Flex
            align="center"
            key={item.id}
            csx={{
              paddingX: 1,
              paddingY: 3,
              border: 'divider-bottom',
              height: 64,
            }}
          >
            {renderItem(item)}
          </Flex>
        ))}
    </DataView>
  )
}

render(<SkeletonCollection />)
```
