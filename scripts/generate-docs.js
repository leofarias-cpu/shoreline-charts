const fs = require('fs')
const prettier = require('prettier')

const prettierConfigPath = require.resolve('../.prettierrc')
const prettierConfig = require(prettierConfigPath)
const path = require('path')

/**
 * This script is responsible for generating the docs for the components and
 * hooks of a package. It uses typedoc to generate the docs and then it splits
 * the generated docs into multiple nextra files.
 *
 * It also generates a Sandpack example for each component and hook.
 *
 * The script is run manually, but it could be packaged as a separate module
 * and published to npm to benefit the community.
 */
class AutogeneratedNextraDocs {
  constructor(props) {
    const {
      paths: { pagesPath = '', componentsMetaPath = '', hooksMetaPath = '' },
      package: { name = '', version = '' },
    } = props

    const cwd = process.cwd()

    this.config = {
      package: {
        name,
        version,
      },
      paths: {
        pagesPath,
        componentsMetaPath,
        hooksMetaPath,
        cwd,
        tmp: `${cwd}/__tmpDocs`,
      },
      // Tokens used to parse the generated docs
      // into meaningful nextra files
      tokens: {
        interfaces: 'Interfaces',
        props: 'Props',
        md: '.md',
        propsMd: 'Props.md',
        tsxCodeBlockHeader:
          '```tsx copy showLineNumbers filename="example.tsx"',
        tsxCodeBlockEnd: '```',
        typeAlias: '## Type Aliases',
        separator: '___',
        methodDocStart: '###',
        empty: '',
      },
    }

    this.init()
  }

  /**
   * Removes all occurrences of a substring from a string
   *
   * @param {string} str
   * @param {string | string[]} substring
   * @returns
   */
  removeSubstring(str, substring) {
    if (typeof substring === 'string') {
      return str.replace(substring, this.config.tokens.empty)
    }

    if (Array.isArray(substring)) {
      let parsedString = str

      for (const sub of substring) {
        parsedString = parsedString.replace(sub, this.config.tokens.empty)
      }

      return parsedString
    }
  }

  /**
   * Transform a string from PascalCase to kebab-case
   *
   * @param {string} str
   * @returns
   */
  pascalCaseToKebabCase(str) {
    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()
  }

  /**
   * Finds references to interfaces and props files and replaces them with
   * the correct path
   *
   * @param {string} file
   * @returns
   */
  toRelativeLinks(file) {
    let parsedFile = file

    const interfaceLinks = file.match(
      /\(interfaces\/([A-Z][a-zA-Z0-9]*)Props.md\)/g
    )

    const propsLinks = file.match(/(\([A-Z][a-zA-Z0-9]*)Props.md\)/g)

    if (interfaceLinks) {
      for (const link of interfaceLinks) {
        const componentName = this.removeSubstring(link, [
          '(interfaces/',
          'Props.md)',
        ])

        const updatedLink = link.replaceAll(
          `interfaces/${componentName}Props.md`,
          `/components/${this.pascalCaseToKebabCase(componentName)}/props.md`
        )

        parsedFile = parsedFile.replaceAll(link, updatedLink)
      }
    }

    if (propsLinks) {
      for (const link of propsLinks) {
        const componentName = this.removeSubstring(link, ['(', 'Props.md)'])

        const updatedLink = link.replace(
          `${componentName}Props.md`,
          `/components/${this.pascalCaseToKebabCase(componentName)}/props.md`
        )

        parsedFile = parsedFile.replaceAll(link, updatedLink)
      }
    }

    return parsedFile
  }

  /**
   * Generate a Sandpack template from a given example
   *
   * @param {string} example
   * @returns
   */
  exampleToSandpackTemplate(example) {
    // Extract components from example
    const components = example.match(/<([A-Z][a-zA-Z0-9]*)/g)
    // Remove duplicate components
    const uniqueComponents = [
      ...new Set(
        components.map((component) => this.removeSubstring(component, '<'))
      ),
    ]

    // Import components from the package.name on a single import line
    const imports = `import { ${uniqueComponents.join(', ')} } from '${
      this.config.package.name
    }'`

    // Removes markdown code block
    const parsedExample = this.removeSubstring(example, [
      this.config.tokens.tsxCodeBlockHeader,
      this.config.tokens.tsxCodeBlockEnd,
    ])

    // Add example within export default
    const exportedExample = `
export default function App() { 
  return (<>${parsedExample}</>
)}`

    const code = `import React from 'react'\n${imports}\n${exportedExample}`

    // Add imports and example to template
    const template =
      `
  import {
    SandpackProvider,
    SandpackLayout,
    SandpackCodeEditor,
    SandpackPreview,
  } from '@codesandbox/sandpack-react' 
  
  <SandpackProvider 
    template="react" 
    theme="dark"
    customSetup={{ dependencies: { '${this.config.package.name}': '${this.config.package.version}' } }}
    files={{'/App.js': ` +
      `\`${code}\`` +
      `,
    }}
  >
    <SandpackLayout>
      <SandpackCodeEditor />
      <SandpackPreview />
    </SandpackLayout>
  </SandpackProvider>`

    return template
  }

  /**
   * Add a Sandpack example to the docs based on a given `@example` jsDoc block.
   *
   * @param {string} file
   * @returns
   */
  addSandpack(file) {
    const exampleIndex = file.indexOf(this.config.tokens.tsxCodeBlockHeader)

    const exampleEndIndex = file.indexOf(
      `${this.config.tokens.tsxCodeBlockEnd}\n`,
      exampleIndex
    )

    if (exampleIndex === -1 || exampleEndIndex === -1) {
      return file
    }

    const example = file.substring(
      exampleIndex,
      exampleEndIndex + this.config.tokens.tsxCodeBlockEnd.length
    )

    const template = this.exampleToSandpackTemplate(example)

    const newExample = `${example}\n\n${template}`

    return file.replace(example, newExample)
  }

  /**
   * Copy a folder recursively
   *
   * @param {string} source
   * @param {string} target
   */
  copyFolderRecursiveSync(source, target) {
    const self = this
    const targetFolder = path.join(target, path.basename(source))

    if (!fs.existsSync(targetFolder)) {
      fs.mkdirSync(targetFolder)
    }

    // Copy while preserving the content from the target folder
    if (fs.lstatSync(source).isDirectory()) {
      const files = fs.readdirSync(source)

      files.forEach(function (file) {
        const curSource = path.join(source, file)

        if (fs.lstatSync(curSource).isDirectory()) {
          self.copyFolderRecursiveSync(curSource, targetFolder)
        } else {
          fs.copyFileSync(curSource, path.join(targetFolder, file))
        }
      })
    }
  }

  /**
   * Split the generated docs from typedoc into multiple nextra files.
   * This is the main function of the script.
   */
  init() {
    const rootFile = fs.readFileSync(
      `${this.config.paths.tmp}/modules.md`,
      'utf8'
    )

    const interfacesFiles = fs.readdirSync(
      `${this.config.paths.tmp}/interfaces`
    )

    const rootFileContent = this.toRelativeLinks(rootFile)
      // typedoc-plugin-markdown generates a single file with all the docs separated by "___"
      .split(this.config.tokens.separator)

    const components = []
    const hooks = []

    for (const fileContents of rootFileContent) {
      try {
        // Parse file contents
        const content = fileContents.split('\n')

        const methodName = content
          // Find the line that starts with "###", which is the component/method/hook name
          .find((line) => line.startsWith(this.config.tokens.methodDocStart))
          .replace(this.config.tokens.methodDocStart, this.config.tokens.empty)
          .trim()

        // Means that this is a component
        const isPascalCase = /^[A-Z][a-zA-Z0-9]*$/.test(methodName)
        // Means that this is a hook, matches camelCase methods starting with "use"
        const isHook = /^use[A-Z][a-zA-Z0-9]*$/.test(methodName)
        // Check if element is a component. This is a bit hacky, but it works
        // since typedoc classifies type-declared type as type aliases under
        // the modules.md file, while it separates interface-declared types
        // under the interfaces folder
        const isTypeAlias = methodName.includes(this.config.tokens.props)

        if (isHook && !isTypeAlias) {
          this.handleHooks(methodName, fileContents, hooks)

          continue
        }

        if (isPascalCase && !isHook && !isTypeAlias) {
          this.handleComponents(
            methodName,
            fileContents,
            interfacesFiles,
            components
          )

          continue
        }

        if (isTypeAlias && !isHook) {
          this.handleTypeAliases(methodName, fileContents)

          continue
        }
      } catch (error) {
        console.error(error)
      }
    }

    // Move everything under config.paths.tmp to the docs folder
    const pagesPath = `${this.config.paths.cwd}${this.config.paths.pagesPath}`
    const componentsMetaJson = `${this.config.paths.cwd}${this.config.paths.componentsMetaPath}`
    const hooksMetaJson = `${this.config.paths.cwd}${this.config.paths.hooksMetaPath}`

    this.copyFolderRecursiveSync(
      `${this.config.paths.tmp}/components`,
      pagesPath
    )

    // Update componentsMetaJson with the new paths
    // Adds the components as kebab-case on keys and PascalCase on values
    const componentsMetaUpdated = Object.assign(
      components.reduce((acc, cur) => {
        return {
          ...acc,
          [this.pascalCaseToKebabCase(cur)]: cur,
        }
      }, {}),
      // Add the Hooks key as the last item on the componentsMetaJson
      {
        hooks: 'Hooks',
      }
    )

    // Write the updated componentsMetaJson to disk as a simple JSON file
    fs.writeFileSync(
      componentsMetaJson,
      JSON.stringify(componentsMetaUpdated, null, 2)
    )

    // Update hooksMetaJson with the new paths
    // Adds the components as kebab-case on keys and camelCase on values
    const hooksMetaUpdated = hooks.reduce((acc, cur) => {
      return {
        ...acc,
        [this.pascalCaseToKebabCase(cur)]: cur,
      }
    }, {})

    // Write the updated componentsMetaJson
    fs.writeFileSync(hooksMetaJson, JSON.stringify(hooksMetaUpdated, null, 2))

    // Remove temporary folder
    fs.rmdirSync(this.config.paths.tmp, { recursive: true })
  }

  /**
   * Prettify a file using the .prettierrc config
   *
   * @param {string} filePath
   */
  prettify(filePath) {
    const prettierOptions = {
      ...prettierConfig,
      parser: 'markdown',
    }

    const file = fs.readFileSync(filePath, 'utf8')
    const formatted = prettier.format(file, prettierOptions)

    fs.writeFileSync(filePath, formatted)
  }

  /**
   * Add a component to the docs
   *
   * @param {string} methodName
   * @param {string} fileContents
   * @param {string[]} interfacesFiles
   * @param {string[]} components
   */
  handleComponents(methodName, fileContents, interfacesFiles, components) {
    const kebabCaseName = this.pascalCaseToKebabCase(methodName)
    const folderPath = `${this.config.paths.tmp}/components/${kebabCaseName}`

    fs.mkdirSync(folderPath, {
      recursive: true,
    })

    const filePath = `${folderPath}/code.mdx`

    let parsedFileContents = fileContents
      // Replace type annotations with the jsx syntax
      .replaceAll('```ts', this.config.tokens.tsxCodeBlockHeader)
      // Replace the link reference to the interface file with the props file
      .replaceAll(`(interfaces/${methodName}Props.md)`, '(props.md)')

    parsedFileContents = this.addSandpack(parsedFileContents)

    fs.writeFileSync(filePath, parsedFileContents)

    this.prettify(filePath)

    components.push(methodName)

    const correspondingInterface = interfacesFiles.find(
      (i) =>
        this.removeSubstring(i, [
          this.config.tokens.md,
          this.config.tokens.props,
        ]) === methodName
    )

    if (correspondingInterface) {
      const interfaceFile = fs.readFileSync(
        `${this.config.paths.tmp}/interfaces/${correspondingInterface}`,
        'utf8'
      )

      const interfaceFilePath = `${folderPath}/props.mdx`

      const parsedInterfaceFile = this.toRelativeLinks(interfaceFile)
        // Replace the interface name with the component name on the title
        .replace('Interface: ', this.config.tokens.empty)
        // Use the component kebab-case name when referencing some id on the page
        .replaceAll(`${correspondingInterface}#`, `props.md#`)

      fs.writeFileSync(interfaceFilePath, parsedInterfaceFile)

      this.prettify(interfaceFilePath)
    }
  }

  /**
   * Handles type aliases, which are interfaces that are declared as types
   * instead of interfaces. This is necessary because typedoc does not
   * generate a separate file for type aliases, so we need to create it
   * manually.
   *
   * @param {string} methodName
   * @param {string} fileContents
   */
  handleTypeAliases(methodName, fileContents) {
    const kebabCaseName = this.pascalCaseToKebabCase(methodName).replace(
      '-props',
      this.config.tokens.empty
    )

    const folderPath = `${this.config.paths.tmp}/components/${kebabCaseName}`

    fs.mkdirSync(folderPath, {
      recursive: true,
    })

    const filePath = `${folderPath}/props.mdx`

    // Replace the link reference to the interface file with the props file
    let parsedFileContents = fileContents

    // Removes the interfaces list that preceeds the type aliases
    // from the typedoc generated file. This is only necessary for
    // the first type alias, since the others are already separated
    if (fileContents.includes(this.config.tokens.typeAlias)) {
      parsedFileContents = fileContents.split(this.config.tokens.typeAlias)[1]
    }

    fs.writeFileSync(filePath, parsedFileContents)

    this.prettify(filePath)
  }

  /**
   * Add a hook to the docs
   *
   * @param {string} methodName
   * @param {string} fileContents
   * @param {string[]} hooks
   */
  handleHooks(methodName, fileContents, hooks) {
    const kebabCaseName = this.pascalCaseToKebabCase(methodName)
    const folderPath = `${this.config.paths.tmp}/components/hooks/${kebabCaseName}`

    fs.mkdirSync(folderPath, {
      recursive: true,
    })

    const filePath = `${folderPath}/code.mdx`

    fs.writeFileSync(filePath, fileContents)

    this.prettify(filePath)

    hooks.push(methodName)
  }
}

new AutogeneratedNextraDocs({
  package: {
    name: '@vtex/shoreline-components',
    version: '^0.x',
  },
  paths: {
    pagesPath: `/packages/next-docs/pages`,
    componentsMetaPath: `/packages/next-docs/pages/components/_meta.json`,
    hooksMetaPath: `/packages/next-docs/pages/components/hooks/_meta.json`,
  },
})
