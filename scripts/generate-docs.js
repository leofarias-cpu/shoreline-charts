const fs = require('fs')
const prettier = require('prettier')

const prettierConfigPath = require.resolve('../.prettierrc')
const prettierConfig = require(prettierConfigPath)
const path = require('path')

// @todos
// [ ] Lint for typedocs
// [ ] Split util methods into separate files
// [ ] Create use cases for: Simple components vs Stateful components vs Hooks vs Compound components
// [ ] What does "NOTE: Exotic components are not callable" mean?
// [ ] Put examples on hold
// [ ] Move hierarchy to related components
// [ ] Compound components hierarchy: Combobox ComboboxItem | Combobox > ComboboxItem

/**
 * This script is responsible for generating the docs for the components and
 * hooks of a package. It uses typedoc to generate the docs and then it splits
 * the generated docs into multiple nextra files.
 *
 * It also generates a Sandpack example for each component and hook.
 *
 * The script is run manually, but it could be packaged as a separate module
 * and published to npm to benefit the community.
 */
class AutogeneratedDocs {
  constructor(props) {
    const cwd = process.cwd()

    /**
     * Regex patterns used to parse the generated docs
     */
    this.regexPatterns = {
      camelCase: '[A-Z][a-zA-Z0-9]*',
    }

    /**
     * Tokens used to parse the generated docs
     */
    this.tokens = {
      interfaces: 'Interfaces',
      interfaceHeader: 'Interface: ',
      typeAliasHeader: '## Type Aliases',
      functionsHeader: '## Functions',
      props: 'Props',
      md: '.md',
      propsMd: 'Props.md',
      tsxCodeBlockHeader: '```tsx copy showLineNumbers filename="example.tsx"',
      tsxCodeBlockEnd: '```',
      separator: '___',
      methodDocStart: '###',
      empty: '',
    }

    /**
     * Regexes used to parse the generated docs
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions
     */
    this.regexes = {
      camelCase: new RegExp(`^${this.regexPatterns.camelCase}$`),
      pascalCase: /([a-z0-9])([A-Z])/g,
      definedInInternal: /#### Defined in\n\n\[[^\]]+\]\([^)]+\)/g,
      definedInExternal: /#### Defined in\n\nnode_modules\/[^:]+:[0-9]+/g,
      /**
       * The first components of the generated docs are preceeded by a Functions
       * header. This function removes this header from the first component documented
       * along with everything that preceeds it.
       */
      functionsHeader: /[\s\S]*?(?=## Functions)/,
      returnsHeader: /#### Returns\n\n((?:(?!\n\n.+)[\s\S])*)/g,
      interfacesLinks: new RegExp(
        `(interfaces/(${this.regexPatterns.camelCase})${this.tokens.propsMd})`,
        'g'
      ),
      propsLinks: new RegExp(
        `((${this.regexPatterns.camelCase})${this.tokens.propsMd})`,
        'g'
      ),
      componentDeclaration: new RegExp(
        `<(${this.regexPatterns.camelCase})`,
        'g'
      ),
    }

    this.paths = {
      cwd,
      tmp: `${cwd}/__tmpDocs`,
    }

    const { packages, rootPath } = props

    for (const pkg of packages) {
      const { name, version, paths } = pkg
      this.generateDocs(name, version, paths, rootPath)
    }
  }

  /**
   * Removes all occurrences of a substring from a string
   *
   * @param {string} str
   * @param {string | string[]} substring
   * @returns
   */
  removeSubstring(str, substring) {
    if (typeof substring === 'string' || substring instanceof RegExp) {
      return str.replace(substring, this.tokens.empty)
    }

    if (Array.isArray(substring)) {
      let parsedString = str

      for (const sub of substring) {
        parsedString = parsedString.replace(sub, this.tokens.empty)
      }

      return parsedString
    }
  }

  /**
   * Transform a string from PascalCase to kebab-case
   *
   * @param {string} str
   * @returns
   */
  pascalCaseToKebabCase(str) {
    return str.replace(this.regexes.pascalCase, '$1-$2').toLowerCase()
  }

  /**
   * Finds references to interfaces and props files and replaces them with
   * the correct path
   *
   * @param {string} file
   * @returns
   */
  toRelativeLinks(file) {
    let parsedFile = file

    const interfaceLinks = file.match(this.regexes.interfacesLinks)
    const propsLinks = file.match(this.regexes.propsLinks)

    if (interfaceLinks) {
      for (const link of interfaceLinks) {
        const componentName = this.removeSubstring(link, [
          'interfaces/',
          'Props.md',
        ])

        const updatedLink = link.replaceAll(
          `interfaces/${componentName}Props.md`,
          `/components/${this.pascalCaseToKebabCase(componentName)}/props.md`
        )

        parsedFile = parsedFile.replaceAll(link, updatedLink)
      }
    }

    if (propsLinks) {
      for (const link of propsLinks) {
        const componentName = this.removeSubstring(link, ['Props.md'])

        const updatedLink = link.replace(
          `${componentName}Props.md`,
          `/components/${this.pascalCaseToKebabCase(componentName)}/props.md`
        )

        parsedFile = parsedFile.replaceAll(link, updatedLink)
      }
    }

    return parsedFile
  }

  /**
   * Generate a Sandpack template from a given example.
   * This could be ported to use any other code playground provider.
   *
   * @param {string} example
   * @returns
   */
  async exampleToPlayground(example, pkg) {
    const { name, version } = pkg

    // Extract components from example
    const components = example.match(this.regexes.componentDeclaration)
    // Remove duplicate components
    const uniqueComponents = [
      ...new Set(
        components?.map((component) => this.removeSubstring(component, '<'))
      ),
    ]

    // Import components from the package.name on a single import line
    const imports = `import { ${uniqueComponents.join(', ')} } from '${name}'`

    // Removes markdown code block
    const parsedExample = this.removeSubstring(example, [
      this.tokens.tsxCodeBlockHeader,
      this.tokens.tsxCodeBlockEnd,
    ])

    // Add example within export default
    const exportedExample = `
  export default function App() { 
    return (
      <>
        ${parsedExample
          .split('\n')
          .map((line) => `      ${line}`)
          .join('\n')}
      </>
    );
  }`

    const code = `import React from 'react';
  ${imports}
  ${exportedExample}`

    try {
      const standard = await import('standard')
      const formattedCode = (
        await standard.default.lintText(code, {
          fix: true,
        })
      )[0].output

      // Add imports and example to template
      const template = `
  import {
    SandpackProvider,
    SandpackLayout,
    SandpackCodeEditor,
    SandpackPreview,
  } from '@codesandbox/sandpack-react';
  
  <SandpackProvider 
    template="react" 
    theme="dark"
    customSetup={{ dependencies: { '${name}': '${version}' } }}
    files={{
      '/App.js': \`${formattedCode}\`,
    }}
  >
    <SandpackLayout>
      <SandpackCodeEditor />
      <SandpackPreview />
    </SandpackLayout>
  </SandpackProvider>`

      return template
    } catch (error) {
      console.error(error)

      return ''
    }
  }

  /**
   * Add a Sandpack example to the docs based on a given `@example` jsDoc block.
   *
   * @param {string} file
   * @returns
   */
  async addPlayground(file, pkg) {
    const exampleIndex = file.indexOf(this.tokens.tsxCodeBlockHeader)

    const exampleEndIndex = file.indexOf(
      `${this.tokens.tsxCodeBlockEnd}\n`,
      exampleIndex
    )

    if (exampleIndex === -1 || exampleEndIndex === -1) {
      return file
    }

    const example = file.substring(
      exampleIndex,
      exampleEndIndex + this.tokens.tsxCodeBlockEnd.length
    )

    const template = await this.exampleToPlayground(example, pkg)

    const newExample = `${example}\n${template}`

    return file.replace(example, newExample)
  }

  /**
   * Create or update a file
   *
   * @param {string} filePath
   */
  async createOrUpdateFile(filePath, content) {
    if (!fs.existsSync(filePath)) {
      // Create file with content on filePath
      await new Promise((res, reject) => {
        fs.writeFile(filePath, content, (err) => {
          if (err) {
            console.error('Error writing to file:', err)
            reject(err)
          }

          res(true)
        })
      })
    } else {
      fs.writeFileSync(filePath, content)
    }
  }

  /**
   * Copy a folder recursively and sychronously
   *
   * @param {string} source
   * @param {string} target
   */
  copyFolderRecursiveSync(source, target) {
    const self = this
    const targetFolder = path.join(target, path.basename(source))

    if (!fs.existsSync(targetFolder)) {
      fs.mkdirSync(targetFolder)
    }

    // Copy while preserving the content from the target folder
    if (fs.lstatSync(source).isDirectory()) {
      const files = fs.readdirSync(source)

      files.forEach(function (file) {
        const curSource = path.join(source, file)

        if (fs.lstatSync(curSource).isDirectory()) {
          self.copyFolderRecursiveSync(curSource, targetFolder)
        } else {
          fs.copyFileSync(curSource, path.join(targetFolder, file))
        }
      })
    }
  }

  cleanFile(rootFile) {
    const step1 = this.toRelativeLinks(rootFile)
    const step2 = this.removeSubstring(step1, [
      this.regexes.definedInInternal,
      this.regexes.definedInExternal,
      this.regexes.functionsHeader,
      this.tokens.functionsHeader,
      this.regexes.returnsHeader,
    ])
    // typedoc-plugin-markdown generates a single file with all the docs separated by "___"
    const step3 = step2.split(this.tokens.separator)

    return step3
  }

  /**
   * Split the generated docs from typedoc into multiple nextra files.
   * This is the main function of the script.
   */
  async generateDocs(name, version, paths, rootPath) {
    const { componentsPath, hooksPath } = paths

    const rootFile = fs.readFileSync(`${this.paths.tmp}/modules.md`, 'utf8')
    const interfacesFiles = fs.readdirSync(`${this.paths.tmp}/interfaces`)

    const rootFileContent = this.cleanFile(rootFile)

    const components = []
    const hooks = []

    for (const fileContents of rootFileContent) {
      try {
        // Parse file contents
        const content = fileContents.split('\n')

        const methodName = content
          // Find the line that starts with "###", which is the component/method/hook name
          .find((line) => line.startsWith(this.tokens.methodDocStart))
          .replace(this.tokens.methodDocStart, this.tokens.empty)
          .trim()

        // Means that this is a component
        const isPascalCase = /^[A-Z][a-zA-Z0-9]*$/.test(methodName)
        // Means that this is a hook, matches camelCase methods starting with "use"
        const isHook = /^use[A-Z][a-zA-Z0-9]*$/.test(methodName)
        // Check if element is a component. This is a bit hacky, but it works
        // since typedoc classifies type-declared type as type aliases under
        // the modules.md file, while it separates interface-declared types
        // under the interfaces folder
        const isTypeAlias = methodName.includes(this.tokens.props)

        if (isHook && !isTypeAlias) {
          await this.handleHooks(methodName, fileContents, hooks)

          continue
        }

        if (isPascalCase && !isHook && !isTypeAlias) {
          await this.handleComponents(
            methodName,
            fileContents,
            interfacesFiles,
            components,
            { name, version }
          )

          continue
        }

        if (isTypeAlias && !isHook) {
          await this.handleTypeAliases(methodName, fileContents)

          continue
        }
      } catch (error) {
        console.error(error)
      }
    }

    // Move everything under config.paths.tmp to the docs folder
    const pagesPath = `${this.paths.cwd}${rootPath}`
    const componentsMetaJson = `${this.paths.cwd}${componentsPath}/_meta.json`
    const hooksMetaJson = `${this.paths.cwd}${hooksPath}/_meta.json`

    // Base path is set to /components here but could come from some configuration
    this.copyFolderRecursiveSync(`${this.paths.tmp}/components`, pagesPath)

    if (components.length > 0) {
      // Update componentsMetaJson with the new paths
      // Adds the components as kebab-case on keys and PascalCase on values
      let componentsMetaUpdated = components.reduce((acc, cur) => {
        return {
          ...acc,
          [this.pascalCaseToKebabCase(cur)]: cur,
        }
      }, {})

      if (hooks.length > 0) {
        componentsMetaUpdated = Object.assign(
          componentsMetaUpdated,
          // Add the Hooks key as the last item on the componentsMetaJson
          {
            hooks: 'Hooks',
          }
        )
      }

      // Write the updated componentsMetaJson to disk as a simple JSON file
      await this.createOrUpdateFile(
        componentsMetaJson,
        JSON.stringify(componentsMetaUpdated, null, 2)
      )
    }

    if (hooks.length > 0) {
      // Update hooksMetaJson with the new paths
      // Adds the components as kebab-case on keys and camelCase on values
      const hooksMetaUpdated = hooks.reduce((acc, cur) => {
        return {
          ...acc,
          [this.pascalCaseToKebabCase(cur)]: cur,
        }
      }, {})

      // Write the updated componentsMetaJson or create if not exists
      await this.createOrUpdateFile(
        hooksMetaJson,
        JSON.stringify(hooksMetaUpdated, null, 2)
      )
    }

    // Remove temporary folder
    fs.rmdirSync(this.paths.tmp, { recursive: true })
  }

  /**
   * Prettify a file using the .prettierrc config
   *
   * @param {string} filePath
   */
  async prettify(filePath) {
    const prettierOptions = {
      ...prettierConfig,
      parser: 'markdown',
    }

    const file = fs.readFileSync(filePath, 'utf8')
    const formatted = prettier.format(file, prettierOptions)

    await this.createOrUpdateFile(filePath, formatted)
  }

  /**
   * Add a component to the docs
   *
   * @param {string} methodName
   * @param {string} fileContents
   * @param {string[]} interfacesFiles
   * @param {string[]} components
   * @param {object} pkg
   */
  async handleComponents(
    methodName,
    fileContents,
    interfacesFiles,
    components,
    pkg
  ) {
    const kebabCaseName = this.pascalCaseToKebabCase(methodName)
    const folderPath = `${this.paths.tmp}/components/${kebabCaseName}`

    fs.mkdirSync(folderPath, {
      recursive: true,
    })

    const filePath = `${folderPath}/code.mdx`

    let parsedFileContents = fileContents
      // Replace type annotations with the jsx syntax
      .replaceAll('```ts', this.tokens.tsxCodeBlockHeader)
      // Replace the link reference to the interface file with the props file
      .replaceAll(`(interfaces/${methodName}Props.md)`, '(props.md)')

    parsedFileContents = await this.addPlayground(parsedFileContents, pkg)
    await this.createOrUpdateFile(filePath, parsedFileContents)

    this.prettify(filePath)

    components.push(methodName)

    const correspondingInterface = interfacesFiles.find(
      (i) =>
        this.removeSubstring(i, [this.tokens.md, this.tokens.props]) ===
        methodName
    )

    if (correspondingInterface) {
      const interfaceFile = fs.readFileSync(
        `${this.paths.tmp}/interfaces/${correspondingInterface}`,
        'utf8'
      )

      const interfaceFilePath = `${folderPath}/props.mdx`

      const parsedInterfaceFile = this.removeSubstring(
        this.toRelativeLinks(interfaceFile)
          // Replace the interface name with the component name on the title
          .replace(this.tokens.interfaceHeader, this.tokens.empty)
          // Use the component kebab-case name when referencing some id on the page
          .replaceAll(`${correspondingInterface}#`, `props.md#`),
        [this.regexes.definedInInternal, this.regexes.definedInExternal]
      )

      await this.createOrUpdateFile(interfaceFilePath, parsedInterfaceFile)

      this.prettify(interfaceFilePath)
    }
  }

  /**
   * Handles type aliases, which are interfaces that are declared as types
   * instead of interfaces. This is necessary because typedoc does not
   * generate a separate file for type aliases, so we need to create it
   * manually.
   *
   * @param {string} methodName
   * @param {string} fileContents
   */
  async handleTypeAliases(methodName, fileContents) {
    const kebabCaseName = this.pascalCaseToKebabCase(methodName).replace(
      '-props',
      this.tokens.empty
    )

    const folderPath = `${this.paths.tmp}/components/${kebabCaseName}`

    fs.mkdirSync(folderPath, {
      recursive: true,
    })

    const filePath = `${folderPath}/props.mdx`

    // Replace the link reference to the interface file with the props file
    let parsedFileContents = fileContents

    // Removes the interfaces list that preceeds the type aliases
    // from the typedoc generated file. This is only necessary for
    // the first type alias, since the others are already separated
    if (fileContents.includes(this.tokens.typeAliasHeader)) {
      parsedFileContents = fileContents.split(this.tokens.typeAliasHeader)[1]
    }

    await this.createOrUpdateFile(filePath, parsedFileContents)

    this.prettify(filePath)
  }

  /**
   * Add a hook to the docs
   *
   * @param {string} methodName
   * @param {string} fileContents
   * @param {string[]} hooks
   */
  async handleHooks(methodName, fileContents, hooks) {
    const kebabCaseName = this.pascalCaseToKebabCase(methodName)
    const folderPath = `${this.paths.tmp}/components/hooks/${kebabCaseName}`

    fs.mkdirSync(folderPath, {
      recursive: true,
    })

    const filePath = `${folderPath}/code.mdx`

    await this.createOrUpdateFile(filePath, fileContents)
    this.prettify(filePath)

    hooks.push(methodName)
  }
}

new AutogeneratedDocs({
  packages: [
    {
      name: '@vtex/shoreline-components',
      version: '^0.x',
      paths: {
        componentsPath: `/packages/next-docs/pages/components`,
        hooksPath: `/packages/next-docs/pages/components/hooks`,
      },
    },
  ],
  rootPath: `/packages/next-docs/pages`,
})
